

下面是一套可以直接落地的 **PROMETHEUS 通用风洞 v1**（你现有 Visionary/Miser/Oracle/Synthesis 能无缝接上）。

---

## 1) 通用风洞要解决的 3 个核心问题

1. **可复现**：同一个 workflow、同一套测试集、同一种故障注入 → 结果可回放、可对比
2. **可度量**：成功/失败不是主观；成本/延迟/稳定性/安全 都有机器可算的指标
3. **可迭代**：每次改 prompt/拓扑/模型/工具权限 → 必须过回归门禁（不准“修一个坏十个”）

---

## 2) 风洞输入输出定义（把“需求”编译成“工况”）

### 输入（WindTunnelSpec）

* **SUT**：Workflow JSON（nodes/edges/budgets/capabilities/stop_conditions）
* **ScenarioPack**：测试场景包（任务集合 + 初始上下文 + 约束）
* **FaultProfile**：故障注入配置（概率、强度、位置）
* **Scorers**：评分器集合（功能、事实、格式、策略、安全、成本、延迟、稳定性）
* **RunConfig**：并发、轮数、随机种子、超时、缓存策略

### 输出（WindTunnelReport）

* 分层统计：按任务类型/难度/故障强度 的 pass rate、p95/p99 延迟、成本分布
* 失败簇（Failure Clusters）：最常见 20 类失败模式 + 可复现样本
* 回归对比：相对上一个版本的 Δ（含置信区间）
* 建议：哪些节点/边/预算/权限/提示词 触发了失败

---

## 3) 通用风洞的“工况库”怎么设计（不靠业务）

你要的“通用”不是“什么都测一点”，而是覆盖 **Agent 系统的通用失效模式**。我建议按 6 大工况族（每族都有基础/增强/对抗三档）：

### A. 需求理解与澄清工况

* 模糊目标、冲突约束、多目标权衡
* 指标：澄清率、澄清是否有效（澄清后成功率提升）、误解率

### B. 工具使用与执行工况

* 工具返回空、慢、错、部分成功、数据格式变化
* 指标：工具错误恢复率、重试策略正确性、降级策略命中率

### C. 长链路与状态一致性工况

* 多回合、跨步骤依赖、记忆引用、状态回滚
* 指标：状态漂移率、重复劳动率、目标偏航率

### D. 约束与合规工况

* 输出必须符合 schema、必须引用证据、不得调用某工具、不得泄露
* 指标：schema 合规率、策略违规率、越权工具调用率

### E. 安全对抗工况

* prompt 注入、越狱、数据外泄诱导、工具滥用诱导
* 指标：注入成功率（=系统失败率）、拒答/安全转向正确率

### F. 性能/成本/并发工况（这就是你说的“数字风洞测试”）

* 并发上升、上下文变长、工具吞吐受限、缓存命中变化
* 指标：p95/p99 延迟曲线、吞吐退化曲线、成本上界、超时率、队列堆积

---

## 4) 评分器体系（这决定风洞是否“真”）

通用风洞最容易翻车的点：**“成功判定”太主观**。解决办法是把评分器拆成三层，从硬到软：

### Level 1：硬判定（必须机器可算）

* JSON schema / 正则 / 类型校验
* 工具调用约束（不允许的工具被调用直接 fail）
* 预算与回合数（超预算/超回合直接 fail）
* 关键字段完整性（必须包含 plan、assumptions、citations 等）

### Level 2：可验证判定（通过外部可证据）

* 需要事实时：必须提供可核对证据（检索结果/引用片段/工具输出）
* 对计算类：用 python/规则引擎复算
* 对转换类：做 round-trip（例如格式转换后可逆）

### Level 3：模型裁判（可选，且必须受约束）

* 用“裁判模型”评估是否满足任务意图
* 但要配套：一致性检验（多裁判/温度=0）、偏置监控、抽样人工复核

> 你想要的“数据驱动”，本质就是：Level 1/2 尽量多，Level 3 只补盲区。

---

## 5) 故障注入（FaultProfile）怎么做才像风洞

你现在的 “API 超时、模糊指令” 是对的，但建议系统化到三类注入点：

### 1）用户侧注入

* 模糊、冲突、反复改需求、插入无关指令、社会工程
* 还能做：真实日志分布拟合（比如 20% 模糊、5% 对抗）

### 2）工具侧注入

* Timeout / 5xx / 返回空 / 返回格式变更 / 部分字段缺失 / 速率限制
* 关键：**按工具类型建模**（搜索、数据库、执行器、文件系统、邮件、日历…）

### 3）系统侧注入（最容易被忽略，但最致命）

* 上下文截断、记忆读失败、缓存污染、并发竞争、重复消息、乱序回调
* 这类注入能直接暴露“状态机设计缺陷”和“死循环”

---

## 6) 防死循环与“互踢皮球”的硬机制

别只靠 Miser 的静态审计，风洞里要有硬闸门：

* **max_total_steps / max_turns**：全局上限
* **edge.max_retries + exponential backoff**：边级上限
* **progress watchdog**：连续 N 步没有“状态增量”（例如没有新增证据/没有新工具输出/没有收敛）→ 强制转 Clarify 或 Fail Fast
* **loop signature**：对 (agent_id, tool, params_hash, state_hash) 做签名，重复出现即判定循环

这块会极大提升“通用风洞”的含金量。

---

## 7) 回归门禁（Release Gate）：让系统真正“进化”

你要的“更牛逼”就在这里：**任何一次改动都必须证明没有退化**。

建议门禁按三层：

* **Must-not-regress**：安全违规率、越权调用率、死循环率（必须不升）
* **SLO**：p95 延迟、成本上界、超时率（必须达标）
* **Quality**：分层 pass rate（核心任务集必须 ≥ 基线 - 容忍阈值）

并且强制输出：**失败样本集 + 回放种子**，否则不允许合并。

---